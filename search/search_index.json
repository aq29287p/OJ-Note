{"config":{"indexing":"full","lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"\u9996\u9801"},{"location":"codility/BinaryGap/","text":"","title":"BinaryGap"},{"location":"codility/CyclicRotation/","text":"","title":"CyclicRotation"},{"location":"codility/FloodDepth/","text":"","title":"FloodDepth"},{"location":"codility/LongestPassword/","text":"","title":"LongestPassword"},{"location":"codility/OddOccurrencesInArray/","text":"","title":"OddOccurrencesInArray"},{"location":"codility/PrefixSet/","text":"","title":"PrefixSet"},{"location":"intro/","text":"Online Judge Note \ud83d\udcdd Solutions and notes of the problems on online judge platforms like LeetCode, Codility and HackerRank. \u5206\u679d \u00b6 There are a three branches for difference usage here: main holds the README and License. docs stores the source code of this site . gh-pages hosts the website pages published by GitHub Actions (check the workflow file ). \u5feb\u901f\u958b\u59cb \u00b6 # clone the project and checkout to 'docs' branch $ git clone https://github.com/Hsins/OJ-Note $ cd OJ-Note && git checkout docs # create the virtual environment $ python3 -m venv env # activate the virtual environment $ source env/bin/activate # Unix-like $ . \\e nv \\S cripts \\A ctivate.ps1 # Windows # install dependencies $ pip install -r requirements.txt # start the server $ mkdocs serve \u76f8\u95dc\u5009\u5eab \u00b6 Hsins/Codility | GitHub Hsins/HackerRank | GitHub Hsins/LeetCode | GitHub \u6388\u6b0a\u8a31\u53ef \u00b6 Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"\u95dc\u65bc\u672c\u7ad9"},{"location":"intro/#_1","text":"There are a three branches for difference usage here: main holds the README and License. docs stores the source code of this site . gh-pages hosts the website pages published by GitHub Actions (check the workflow file ).","title":"\u5206\u679d"},{"location":"intro/#_2","text":"# clone the project and checkout to 'docs' branch $ git clone https://github.com/Hsins/OJ-Note $ cd OJ-Note && git checkout docs # create the virtual environment $ python3 -m venv env # activate the virtual environment $ source env/bin/activate # Unix-like $ . \\e nv \\S cripts \\A ctivate.ps1 # Windows # install dependencies $ pip install -r requirements.txt # start the server $ mkdocs serve","title":"\u5feb\u901f\u958b\u59cb"},{"location":"intro/#_3","text":"Hsins/Codility | GitHub Hsins/HackerRank | GitHub Hsins/LeetCode | GitHub","title":"\u76f8\u95dc\u5009\u5eab"},{"location":"intro/#_4","text":"Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"\u6388\u6b0a\u8a31\u53ef"},{"location":"intro/patterns/","text":"Two Pointers \u00b6 Fast/Slow Pointers \u00b6 Merge Intervals \u00b6 Cyclic Sort \u00b6 In-place Reversal of Linked-List \u00b6 Breadth First Search \u00b6 Depth First Search \u00b6 Two Heaps \u00b6 Subsets \u00b6 Modified Binary Search \u00b6 Bitwise XOR \u00b6 Top K Elements \u00b6 K-way Merge \u00b6 0 or 1 Knapsack \u00b6 Topological Sort \u00b6","title":"Patterns"},{"location":"intro/patterns/#two-pointers","text":"","title":"Two Pointers"},{"location":"intro/patterns/#fastslow-pointers","text":"","title":"Fast/Slow Pointers"},{"location":"intro/patterns/#merge-intervals","text":"","title":"Merge Intervals"},{"location":"intro/patterns/#cyclic-sort","text":"","title":"Cyclic Sort"},{"location":"intro/patterns/#in-place-reversal-of-linked-list","text":"","title":"In-place Reversal of Linked-List"},{"location":"intro/patterns/#breadth-first-search","text":"","title":"Breadth First Search"},{"location":"intro/patterns/#depth-first-search","text":"","title":"Depth First Search"},{"location":"intro/patterns/#two-heaps","text":"","title":"Two Heaps"},{"location":"intro/patterns/#subsets","text":"","title":"Subsets"},{"location":"intro/patterns/#modified-binary-search","text":"","title":"Modified Binary Search"},{"location":"intro/patterns/#bitwise-xor","text":"","title":"Bitwise XOR"},{"location":"intro/patterns/#top-k-elements","text":"","title":"Top K Elements"},{"location":"intro/patterns/#k-way-merge","text":"","title":"K-way Merge"},{"location":"intro/patterns/#0-or-1-knapsack","text":"","title":"0 or 1 Knapsack"},{"location":"intro/patterns/#topological-sort","text":"","title":"Topological Sort"},{"location":"intro/references/","text":"\u8cc7\u6599\u7d50\u69cb\u8207\u6f14\u7b97\u6cd5\uff1aLeetCode/LintCode \u984c\u89e3 | Billryan LeetCode All in One \u984c\u76ee\u8b1b\u89e3\u5f59\u7e3d | GrandYang","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"intro/styleguide/","text":"Fundamental \u00b6 Rules \u00b6 Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD) Examples \u00b6 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template \u00b6 Rules \u00b6 There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each variable. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels, each separating a blank line between kernels, but each kernel itself should not be blank in between. return private private variables private function(s) Schematic Template \u00b6 Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; // single line based on clang-format vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { // use `map.count` rather than `map.find` pattern int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; Boundary Conditions \u00b6 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value \u00b6 return ans ; return {}; Data Structure \u00b6 // C++ unordered_set < string > set ; unordered_map < char , int > map ; vector < int > map ; // even if you use array or vector, stick to map queue < TreeNode *> queue ; deque < TreeNode *> deque ; stack < char > stack ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; # Python set_ = set () # or wordSet = set() if you like dict = {} dict = collections . defaultdict ( int ) dict = collections . defaultdict ( list ) queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = [] Two Pointers / Sliding Windows \u00b6 Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) { ... } int l = 0 ; int r = nums . size () - 1 ; Binary Search \u00b6 Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode \u00b6 ListNode dummy ( 0 ); // the only variable that declared statically ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings \u00b6 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing \u00b6 // vector<int> nums; for ( int i = 0 ; i < nums . size (); i ++ ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); i ++ ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... } Pattern \u00b6 Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) length ++ ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; Others \u00b6 Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. int currNum ; TreeNode * currNode ; int maxProfit ; Add a underline ( _ ) after a variable. When there's confliction in expression and function: // C++ min , max , std :: min (), std :: max () # Python min_ , max_ , min (), max () When there's confliction with default reserved words: # Python set_ , set () When there are two maps/stacks, use 1 and 2 suffixes. unordered_map < char , int > map1 ; unordered_map < char , int > map2 ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . const is used iff we get value of size() or length() . auto is used iff when we iterate through a map or declare a variable of ListNode* (except NULL ). Use & whenever possible except int and char . Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"\u98a8\u683c\u898f\u7bc4"},{"location":"intro/styleguide/#fundamental","text":"","title":"Fundamental"},{"location":"intro/styleguide/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD)","title":"Rules"},{"location":"intro/styleguide/#examples","text":"// Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"intro/styleguide/#template","text":"","title":"Template"},{"location":"intro/styleguide/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each variable. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels, each separating a blank line between kernels, but each kernel itself should not be blank in between. return private private variables private function(s)","title":"Rules"},{"location":"intro/styleguide/#schematic-template","text":"Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; // single line based on clang-format vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { // use `map.count` rather than `map.find` pattern int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } };","title":"Schematic Template"},{"location":"intro/styleguide/#boundary-conditions","text":"// Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"intro/styleguide/#return-value","text":"return ans ; return {};","title":"Return Value"},{"location":"intro/styleguide/#data-structure","text":"// C++ unordered_set < string > set ; unordered_map < char , int > map ; vector < int > map ; // even if you use array or vector, stick to map queue < TreeNode *> queue ; deque < TreeNode *> deque ; stack < char > stack ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; # Python set_ = set () # or wordSet = set() if you like dict = {} dict = collections . defaultdict ( int ) dict = collections . defaultdict ( list ) queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = []","title":"Data Structure"},{"location":"intro/styleguide/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) { ... } int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"intro/styleguide/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"intro/styleguide/#listnode","text":"ListNode dummy ( 0 ); // the only variable that declared statically ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"intro/styleguide/#2d-vector-2-strings","text":"// 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"intro/styleguide/#traversing","text":"// vector<int> nums; for ( int i = 0 ; i < nums . size (); i ++ ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); i ++ ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"intro/styleguide/#pattern","text":"Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) length ++ ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ;","title":"Pattern"},{"location":"intro/styleguide/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. int currNum ; TreeNode * currNode ; int maxProfit ; Add a underline ( _ ) after a variable. When there's confliction in expression and function: // C++ min , max , std :: min (), std :: max () # Python min_ , max_ , min (), max () When there's confliction with default reserved words: # Python set_ , set () When there are two maps/stacks, use 1 and 2 suffixes. unordered_map < char , int > map1 ; unordered_map < char , int > map2 ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . const is used iff we get value of size() or length() . auto is used iff when we iterate through a map or declare a variable of ListNode* (except NULL ). Use & whenever possible except int and char . Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Others"},{"location":"leetcode/circular-array-loop/","text":"0457. \u74b0\u5f62\u6578\u7d44\u662f\u5426\u5b58\u5728\u5faa\u74b0\uff08Circular Array Loop\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { const int n = nums . size (); if ( n < 2 ) { return false ; } auto advance = [ & ]( int i ) { const int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) { return false ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; final int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False const circularArrayLoop = ( nums ) => { if ( nums . length < 2 ) { return false ; } for ( let i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] === 0 ) { continue ; } let slow = i ; let fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow === fast ) { if ( slow === advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; const sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; }; const advance = ( nums , i ) => { const n = nums . length ; const val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0457. \u74b0\u5f62\u6578\u7d44\u662f\u5426\u5b58\u5728\u5faa\u74b0"},{"location":"leetcode/circular-array-loop/#0457-circular-array-loop","text":"","title":"0457. \u74b0\u5f62\u6578\u7d44\u662f\u5426\u5b58\u5728\u5faa\u74b0\uff08Circular Array Loop\uff09"},{"location":"leetcode/circular-array-loop/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/circular-array-loop/#_1","text":"C++ Java Python JavaScript class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { const int n = nums . size (); if ( n < 2 ) { return false ; } auto advance = [ & ]( int i ) { const int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) { return false ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; final int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False const circularArrayLoop = ( nums ) => { if ( nums . length < 2 ) { return false ; } for ( let i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] === 0 ) { continue ; } let slow = i ; let fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow === fast ) { if ( slow === advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; const sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; }; const advance = ( nums , i ) => { const n = nums . length ; const val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }","title":"\u5be6\u4f5c"},{"location":"leetcode/circular-array-loop/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/contains-duplicate/","text":"0217. \u5b58\u5728\u91cd\u8907\u5143\u7d20\uff08Contains Duplicate\uff09 \u00b6 \u89e3\u7b54\uff1a\u9810\u5148\u6392\u5e8f\uff08Presorting\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { // presorting sort ( nums . begin (), nums . end ()); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . size () - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ]) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { // presorting Arrays . sort ( nums ); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : # presorting nums . sort () # check if there are duplicates by comparing adjacent elements for i in range ( len ( nums ) - 1 ): if nums [ i ] == nums [ i + 1 ]: return True return False const containsDuplicate = function ( nums ) { // presorting nums . sort (( a , b ) => a - b ); // check if there are duplicates by comparing adjacent elements for ( let i = 0 ; i < nums . length - 1 ; ++ i ) { if ( nums [ i ] === nums [ i + 1 ]) { return true ; } } return false ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n \\log{} n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{} n)\\) \u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) { if ( ! seen . insert ( num ). second ) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) { if ( ! seen . add ( num )) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) const containsDuplicate = function ( nums ) { const seen = new Set (); for ( const num of nums ) { if ( seen . has ( num )) { return true ; } seen . add ( num ); } return false ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"0217. \u5b58\u5728\u91cd\u8907\u5143\u7d20"},{"location":"leetcode/contains-duplicate/#0217-contains-duplicate","text":"","title":"0217. \u5b58\u5728\u91cd\u8907\u5143\u7d20\uff08Contains Duplicate\uff09"},{"location":"leetcode/contains-duplicate/#presorting","text":"","title":"\u89e3\u7b54\uff1a\u9810\u5148\u6392\u5e8f\uff08Presorting\uff09"},{"location":"leetcode/contains-duplicate/#_1","text":"C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { // presorting sort ( nums . begin (), nums . end ()); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . size () - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ]) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { // presorting Arrays . sort ( nums ); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : # presorting nums . sort () # check if there are duplicates by comparing adjacent elements for i in range ( len ( nums ) - 1 ): if nums [ i ] == nums [ i + 1 ]: return True return False const containsDuplicate = function ( nums ) { // presorting nums . sort (( a , b ) => a - b ); // check if there are duplicates by comparing adjacent elements for ( let i = 0 ; i < nums . length - 1 ; ++ i ) { if ( nums [ i ] === nums [ i + 1 ]) { return true ; } } return false ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/contains-duplicate/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n \\log{} n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{} n)\\)","title":"\u5206\u6790"},{"location":"leetcode/contains-duplicate/#hash-mapping","text":"","title":"\u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09"},{"location":"leetcode/contains-duplicate/#_3","text":"C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) { if ( ! seen . insert ( num ). second ) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) { if ( ! seen . add ( num )) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) const containsDuplicate = function ( nums ) { const seen = new Set (); for ( const num of nums ) { if ( seen . has ( num )) { return true ; } seen . add ( num ); } return false ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/contains-duplicate/#_4","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"\u5206\u6790"},{"location":"leetcode/happy-number/","tags":["\u5feb\u6162\u6307\u91dd"],"text":"0202. \u5feb\u6a02\u6578\uff08Happy Number\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private : int sumSquare ( int num ) { int sum = 0 ; while ( num ) { sum += pow ( num % 10 , 2 ); num /= 10 ; } return sum ; } }; class Solution { public boolean isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private int sumSquare ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } class Solution : def isHappy ( self , num : int ) -> bool : def calculate_square_sum ( num ): res = 0 while num : digit = num % 10 res = res + digit * digit num = num // 10 return res slow = calculate_square_sum ( num ) fast = calculate_square_sum ( calculate_square_sum ( num )) while slow != fast : slow = calculate_square_sum ( slow ) fast = calculate_square_sum ( calculate_square_sum ( fast )) return slow == 1 const isHappy = ( num ) => { let slow = sumSquare ( num ); let fast = sumSquare ( sumSquare ( num )); while ( slow !== fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow === 1 ; }; const sumSquare = ( num ) => { let sum = 0 ; while ( num ) { sum = sum + Math . pow ( num % 10 , 2 ); num = Math . floor ( num / 10 ); } return sum ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{n})\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0202. \u5feb\u6a02\u6578"},{"location":"leetcode/happy-number/#0202-happy-number","text":"","title":"0202. \u5feb\u6a02\u6578\uff08Happy Number\uff09"},{"location":"leetcode/happy-number/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/happy-number/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private : int sumSquare ( int num ) { int sum = 0 ; while ( num ) { sum += pow ( num % 10 , 2 ); num /= 10 ; } return sum ; } }; class Solution { public boolean isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private int sumSquare ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } class Solution : def isHappy ( self , num : int ) -> bool : def calculate_square_sum ( num ): res = 0 while num : digit = num % 10 res = res + digit * digit num = num // 10 return res slow = calculate_square_sum ( num ) fast = calculate_square_sum ( calculate_square_sum ( num )) while slow != fast : slow = calculate_square_sum ( slow ) fast = calculate_square_sum ( calculate_square_sum ( fast )) return slow == 1 const isHappy = ( num ) => { let slow = sumSquare ( num ); let fast = sumSquare ( sumSquare ( num )); while ( slow !== fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow === 1 ; }; const sumSquare = ( num ) => { let sum = 0 ; while ( num ) { sum = sum + Math . pow ( num % 10 , 2 ); num = Math . floor ( num / 10 ); } return sum ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/happy-number/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{n})\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/insomorphic-strings/","text":"0205. \u540c\u69cb\u5b57\u7b26\u4e32\uff08Isomorphic Strings\uff09 \u00b6 \u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) { return false ; } } return true ; } } class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )] const isIsomorphic = function ( s , t ) { const charToIndex_s = {}; const charToIndex_t = {}; for ( let i = 0 ; i < s . length ; ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0205. \u540c\u69cb\u5b57\u7b26\u4e32"},{"location":"leetcode/insomorphic-strings/#0205-isomorphic-strings","text":"","title":"0205. \u540c\u69cb\u5b57\u7b26\u4e32\uff08Isomorphic Strings\uff09"},{"location":"leetcode/insomorphic-strings/#hash-mapping","text":"","title":"\u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09"},{"location":"leetcode/insomorphic-strings/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) { return false ; } } return true ; } } class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )] const isIsomorphic = function ( s , t ) { const charToIndex_s = {}; const charToIndex_t = {}; for ( let i = 0 ; i < s . length ; ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/insomorphic-strings/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/intersection-of-two-linked-lists/","text":"0160. \u76f8\u4ea4\u93c8\u8868\uff08Intersection of Two Linked Lists\uff09 \u00b6 \u89e3\u7b54\uff1a\u96d9\u6307\u91dd\uff08Two Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : # both linked-list are empty if not headA or not headB : return None a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a const getIntersectionNode = function ( headA , headB ) { // both linked-list are empty if ( ! headA || ! headB ) { return null ; } let a = headA ; let b = headB ; while ( a !== b ) { a = a ? a . next : headB ; b = b ? b . next : headA ; } return a ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(a + b)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0160. \u76f8\u4ea4\u93c8\u8868"},{"location":"leetcode/intersection-of-two-linked-lists/#0160-intersection-of-two-linked-lists","text":"","title":"0160. \u76f8\u4ea4\u93c8\u8868\uff08Intersection of Two Linked Lists\uff09"},{"location":"leetcode/intersection-of-two-linked-lists/#two-pointers","text":"","title":"\u89e3\u7b54\uff1a\u96d9\u6307\u91dd\uff08Two Pointers\uff09"},{"location":"leetcode/intersection-of-two-linked-lists/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : # both linked-list are empty if not headA or not headB : return None a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a const getIntersectionNode = function ( headA , headB ) { // both linked-list are empty if ( ! headA || ! headB ) { return null ; } let a = headA ; let b = headB ; while ( a !== b ) { a = a ? a . next : headB ; b = b ? b . next : headA ; } return a ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/intersection-of-two-linked-lists/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(a + b)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/linked-list-cycle-ii/","text":"0142. \u74b0\u5f62\u93c8\u8868 II\uff08Linked List Cycle II\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } class Solution : def detectCycle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None const detectCycle = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; if ( slow === fast ) { slow = head ; while ( slow !== fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0142. \u74b0\u5f62\u93c8\u8868 II"},{"location":"leetcode/linked-list-cycle-ii/#0142-iilinked-list-cycle-ii","text":"","title":"0142. \u74b0\u5f62\u93c8\u8868 II\uff08Linked List Cycle II\uff09"},{"location":"leetcode/linked-list-cycle-ii/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/linked-list-cycle-ii/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } class Solution : def detectCycle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None const detectCycle = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; if ( slow === fast ) { slow = head ; while ( slow !== fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/linked-list-cycle-ii/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/linked-list-cycle/","text":"0141. \u74b0\u5f62\u93c8\u8868\uff08Linked List Cycle\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { return true ; } } return false ; } } class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : \u3000 # empty linked-list or linked-list with only one node if not head or not head . next : return False # initialize slow and fast pointers slow = head fast = head # move fast pointer two nodes at a time while fast and fast . next : slow = slow . next fast = fast . next . next # if fast pointer ever meets the slow pointer, there is a cycle if slow == fast : return True return False const hasCycle = function ( head ) { // empty linked-list or linked-list with only one node if ( ! head || ! head . next ) { return false ; } // initialize slow and fast pointers let slow = head ; let fast = head ; // move fast pointer two nodes at a time while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; // if fast pointer ever meets the slow pointer, there is a cycle if ( slow === fast ) { return true ; } } return false ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0141. \u74b0\u5f62\u93c8\u8868"},{"location":"leetcode/linked-list-cycle/#0141-linked-list-cycle","text":"","title":"0141. \u74b0\u5f62\u93c8\u8868\uff08Linked List Cycle\uff09"},{"location":"leetcode/linked-list-cycle/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/linked-list-cycle/#_1","text":"C++ Java Python JavaScript class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { return true ; } } return false ; } } class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : \u3000 # empty linked-list or linked-list with only one node if not head or not head . next : return False # initialize slow and fast pointers slow = head fast = head # move fast pointer two nodes at a time while fast and fast . next : slow = slow . next fast = fast . next . next # if fast pointer ever meets the slow pointer, there is a cycle if slow == fast : return True return False const hasCycle = function ( head ) { // empty linked-list or linked-list with only one node if ( ! head || ! head . next ) { return false ; } // initialize slow and fast pointers let slow = head ; let fast = head ; // move fast pointer two nodes at a time while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; // if fast pointer ever meets the slow pointer, there is a cycle if ( slow === fast ) { return true ; } } return false ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/linked-list-cycle/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/merge-two-sorted-lists/","text":"0021. \u5408\u4f75\u5169\u500b\u6709\u5e8f\u93c8\u8868\uff08Merge Two Sorted Lists\uff09 \u00b6 \u89e3\u7b54\uff1a\u905e\u8ff4\uff08recursion\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 -> val > list2 -> val ) { swap ( list1 , list2 ); } list1 -> next = mergeTwoLists ( list1 -> next , list2 ); return list1 ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { if ( list1 == null || list2 == null ) return list1 == null ? list2 : list1 ; if ( list1 . val > list2 . val ) { ListNode temp = list1 ; list1 = list2 ; list2 = temp ; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return l1 ; } } class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: if not list1 or not list2 : return list1 if list1 else list2 if list1 . val > list2 . val : list1 , list2 = list2 , list1 list1 . next = self . mergeTwoLists ( list1 . next , list2 ) return list1 const mergeTwoLists = function ( list1 , list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 . val > list2 . val ) { [ list1 , list2 ] = [ list2 , list1 ]; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u89e3\u7b54\uff1a\u8fed\u4ee3\uff08iteration\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { ListNode * dummy = new ListNode ( NULL ); ListNode * tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 -> val < list2 -> val ) { tail -> next = list1 ; list1 = list1 -> next ; } else { tail -> next = list2 ; list2 = list2 -> next ; } tail = tail -> next ; } // append rest link-list tail -> next = list1 == nullptr ? list2 : list1 ; return dummy -> next ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode ( - 1 ); ListNode tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 != null && list2 != null ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 == null ? list2 : list1 ; return dummy . next ; } }; class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: dummy = ListNode ( - 1 ) tail = dummy # both linked-list are not empty, compare and append the smaller value while list1 and list2 : if list1 . val <= list2 . val : tail . next = list1 list1 = list1 . next else : tail . next = list2 list2 = list2 . next tail = tail . next # append rest link-list tail . next = list1 if list1 else list2 return dummy . next const mergeTwoLists = function ( list1 , list2 ) { const dummy = new ListNode ( - 1 ); let tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 ? list1 : list2 ; return dummy . next ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(1)\\)","title":"0021. \u5408\u4f75\u5169\u500b\u6709\u5e8f\u93c8\u8868"},{"location":"leetcode/merge-two-sorted-lists/#0021-merge-two-sorted-lists","text":"","title":"0021. \u5408\u4f75\u5169\u500b\u6709\u5e8f\u93c8\u8868\uff08Merge Two Sorted Lists\uff09"},{"location":"leetcode/merge-two-sorted-lists/#recursion","text":"","title":"\u89e3\u7b54\uff1a\u905e\u8ff4\uff08recursion\uff09"},{"location":"leetcode/merge-two-sorted-lists/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 -> val > list2 -> val ) { swap ( list1 , list2 ); } list1 -> next = mergeTwoLists ( list1 -> next , list2 ); return list1 ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { if ( list1 == null || list2 == null ) return list1 == null ? list2 : list1 ; if ( list1 . val > list2 . val ) { ListNode temp = list1 ; list1 = list2 ; list2 = temp ; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return l1 ; } } class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: if not list1 or not list2 : return list1 if list1 else list2 if list1 . val > list2 . val : list1 , list2 = list2 , list1 list1 . next = self . mergeTwoLists ( list1 . next , list2 ) return list1 const mergeTwoLists = function ( list1 , list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 . val > list2 . val ) { [ list1 , list2 ] = [ list2 , list1 ]; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/merge-two-sorted-lists/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\)","title":"\u5206\u6790"},{"location":"leetcode/merge-two-sorted-lists/#iteration","text":"","title":"\u89e3\u7b54\uff1a\u8fed\u4ee3\uff08iteration\uff09"},{"location":"leetcode/merge-two-sorted-lists/#_3","text":"C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { ListNode * dummy = new ListNode ( NULL ); ListNode * tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 -> val < list2 -> val ) { tail -> next = list1 ; list1 = list1 -> next ; } else { tail -> next = list2 ; list2 = list2 -> next ; } tail = tail -> next ; } // append rest link-list tail -> next = list1 == nullptr ? list2 : list1 ; return dummy -> next ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode ( - 1 ); ListNode tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 != null && list2 != null ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 == null ? list2 : list1 ; return dummy . next ; } }; class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: dummy = ListNode ( - 1 ) tail = dummy # both linked-list are not empty, compare and append the smaller value while list1 and list2 : if list1 . val <= list2 . val : tail . next = list1 list1 = list1 . next else : tail . next = list2 list2 = list2 . next tail = tail . next # append rest link-list tail . next = list1 if list1 else list2 return dummy . next const mergeTwoLists = function ( list1 , list2 ) { const dummy = new ListNode ( - 1 ); let tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 ? list1 : list2 ; return dummy . next ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/merge-two-sorted-lists/#_4","text":"\u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/middle-of-the-linked-list/","text":"0876. \u93c8\u8868\u7684\u4e2d\u9593\u7d50\u9ede\uff08Middle of the Linked List\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } class Solution : def middleNode ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow const middleNode = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } return slow ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0876. \u93c8\u8868\u7684\u4e2d\u9593\u7d50\u9ede"},{"location":"leetcode/middle-of-the-linked-list/#0876-middle-of-the-linked-list","text":"","title":"0876. \u93c8\u8868\u7684\u4e2d\u9593\u7d50\u9ede\uff08Middle of the Linked List\uff09"},{"location":"leetcode/middle-of-the-linked-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/middle-of-the-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } class Solution : def middleNode ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow const middleNode = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } return slow ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/middle-of-the-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/palindrome-linked-list/","text":"0234. \u56de\u6587\u93c8\u8868\uff08Palindrome Linked List\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) { slow = slow -> next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) { return false ; } slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True const isPalindrome = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } if ( fast ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow . val !== head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; }; const reverseList = ( head ) => { let prev = null ; while ( head != null ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0234. \u56de\u6587\u93c8\u8868"},{"location":"leetcode/palindrome-linked-list/#0234-palindrome-linked-list","text":"","title":"0234. \u56de\u6587\u93c8\u8868\uff08Palindrome Linked List\uff09"},{"location":"leetcode/palindrome-linked-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/palindrome-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) { slow = slow -> next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) { return false ; } slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True const isPalindrome = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } if ( fast ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow . val !== head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; }; const reverseList = ( head ) => { let prev = null ; while ( head != null ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; }","title":"\u5be6\u4f5c"},{"location":"leetcode/palindrome-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/reorder-list/","text":"0143. \u91cd\u6392\u93c8\u8868\uff08Reorder List\uff09 \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } class Solution : def reorderList ( self , head : Optional [ ListNode ]) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed ) const reorderList = ( head ) => { if ( ! head || ! head . next ) { return ; } const mid = findMid ( head ); const reversed = reverse ( mid ); merge ( head , reversed ); }; const findMid = ( head ) => { let prev = null ; let slow = head ; let fast = slow ; while ( fast && fast . next ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } const reverse = ( head ) => { let prev = null ; let curr = head ; while ( curr ) { const next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } const merge = ( list1 , list2 ) => { while ( list2 ) { const next = list1 . next ; list1 . next = list2 ; list1 = list2 ; list2 = next ; } } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0143. \u91cd\u6392\u93c8\u8868"},{"location":"leetcode/reorder-list/#0143-reorder-list","text":"","title":"0143. \u91cd\u6392\u93c8\u8868\uff08Reorder List\uff09"},{"location":"leetcode/reorder-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"leetcode/reorder-list/#_1","text":"C++ Java Python JavaScript class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } class Solution : def reorderList ( self , head : Optional [ ListNode ]) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed ) const reorderList = ( head ) => { if ( ! head || ! head . next ) { return ; } const mid = findMid ( head ); const reversed = reverse ( mid ); merge ( head , reversed ); }; const findMid = ( head ) => { let prev = null ; let slow = head ; let fast = slow ; while ( fast && fast . next ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } const reverse = ( head ) => { let prev = null ; let curr = head ; while ( curr ) { const next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } const merge = ( list1 , list2 ) => { while ( list2 ) { const next = list1 . next ; list1 . next = list2 ; list1 = list2 ; list2 = next ; } }","title":"\u5be6\u4f5c"},{"location":"leetcode/reorder-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/reverse-linked-list/","text":"0206. \u53cd\u8f49\u93c8\u8868\uff08Reverse Linked List\uff09 \u00b6 \u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode * newHead = reverseList ( head -> next ); head -> next -> next = head ; head -> next = nullptr ; return newHead ; } }; class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if not head or not head . next : return head newHead = self . reverseList ( head . next ) head . next . next = head head . next = None return newHead const reverseList = ( head ) => { if ( ! head || ! head . next ) { return head ; } const newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iterative\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev const reverseList = ( head ) => { let prev = null ; while ( head ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0206. \u53cd\u8f49\u93c8\u8868"},{"location":"leetcode/reverse-linked-list/#0206-reverse-linked-list","text":"","title":"0206. \u53cd\u8f49\u93c8\u8868\uff08Reverse Linked List\uff09"},{"location":"leetcode/reverse-linked-list/#recursion","text":"","title":"\u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09"},{"location":"leetcode/reverse-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode * newHead = reverseList ( head -> next ); head -> next -> next = head ; head -> next = nullptr ; return newHead ; } }; class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if not head or not head . next : return head newHead = self . reverseList ( head . next ) head . next . next = head head . next = None return newHead const reverseList = ( head ) => { if ( ! head || ! head . next ) { return head ; } const newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/reverse-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"\u5206\u6790"},{"location":"leetcode/reverse-linked-list/#iterative","text":"","title":"\u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iterative\uff09"},{"location":"leetcode/reverse-linked-list/#_3","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev const reverseList = ( head ) => { let prev = null ; while ( head ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/reverse-linked-list/#_4","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/reverse-nodes-in-k-group/","text":"0025. K \u500b\u4e00\u7d44\u7ffb\u8f49\u93c8\u8868\uff08Reverse Nodes in k-Group\uff09 \u00b6 \u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09 \u00b6 \u5be6\u4f5c \u00b6 \u5206\u6790 \u00b6 \u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iteration\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) { return head ; } ListNode * dummy = new ListNode ( -1 ); ListNode * prev = dummy ; ListNode * curr = head ; dummy -> next = head ; for ( int i = 1 ; curr ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr -> next ); curr = prev -> next ; } else { curr = curr -> next ; } } return dummy -> next ; } ListNode * reverse ( ListNode * head , ListNode * tail ) { ListNode * last = head -> next ; ListNode * curr = last -> next ; while ( curr != tail ) { last -> next = curr -> next ; curr -> next = head -> next ; head -> next = curr ; curr = last -> next ; } return last ; } }; class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) { return head ; } ListNode dummy = new ListNode ( - 1 ); ListNode prev = dummy ; ListNode curr = head ; dummy . next = head ; for ( int i = 1 ; curr != null ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; } private ListNode reverse ( ListNode head , ListNode tail ) { ListNode last = head . next ; ListNode curr = last . next ; while ( curr != tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } } class Solution : def reverseKGroup ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: if not head or k == 1 : return head dummy = ListNode () prev = dummy curr = head dummy . next = head idx = 1 while curr : if idx % k == 0 : prev = self . reverse ( prev , curr . next ) curr = prev . next else : curr = curr . next idx += 1 return dummy . next def reverse ( self , head : Optional [ ListNode ], tail : Optional [ ListNode ]): last = head . next curr = last . next while curr != tail : last . next = curr . next curr . next = head . next head . next = curr curr = last . next return last const reverseKGroup = function ( head , k ) { if ( ! head || k === 1 ) { return head ; } dummy = new ListNode ( - 1 ); prev = dummy ; curr = head ; dummy . next = head ; for ( let i = 1 ; curr ; ++ i ) { if ( i % k === 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; }; const reverse = function ( head , tail ) { last = head . next ; curr = last . next ; while ( curr !== tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0025. K \u500b\u4e00\u7d44\u7ffb\u8f49\u93c8\u8868"},{"location":"leetcode/reverse-nodes-in-k-group/#0025-k-reverse-nodes-in-k-group","text":"","title":"0025. K \u500b\u4e00\u7d44\u7ffb\u8f49\u93c8\u8868\uff08Reverse Nodes in k-Group\uff09"},{"location":"leetcode/reverse-nodes-in-k-group/#recursion","text":"","title":"\u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09"},{"location":"leetcode/reverse-nodes-in-k-group/#_1","text":"","title":"\u5be6\u4f5c"},{"location":"leetcode/reverse-nodes-in-k-group/#_2","text":"","title":"\u5206\u6790"},{"location":"leetcode/reverse-nodes-in-k-group/#iteration","text":"","title":"\u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iteration\uff09"},{"location":"leetcode/reverse-nodes-in-k-group/#_3","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) { return head ; } ListNode * dummy = new ListNode ( -1 ); ListNode * prev = dummy ; ListNode * curr = head ; dummy -> next = head ; for ( int i = 1 ; curr ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr -> next ); curr = prev -> next ; } else { curr = curr -> next ; } } return dummy -> next ; } ListNode * reverse ( ListNode * head , ListNode * tail ) { ListNode * last = head -> next ; ListNode * curr = last -> next ; while ( curr != tail ) { last -> next = curr -> next ; curr -> next = head -> next ; head -> next = curr ; curr = last -> next ; } return last ; } }; class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) { return head ; } ListNode dummy = new ListNode ( - 1 ); ListNode prev = dummy ; ListNode curr = head ; dummy . next = head ; for ( int i = 1 ; curr != null ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; } private ListNode reverse ( ListNode head , ListNode tail ) { ListNode last = head . next ; ListNode curr = last . next ; while ( curr != tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } } class Solution : def reverseKGroup ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: if not head or k == 1 : return head dummy = ListNode () prev = dummy curr = head dummy . next = head idx = 1 while curr : if idx % k == 0 : prev = self . reverse ( prev , curr . next ) curr = prev . next else : curr = curr . next idx += 1 return dummy . next def reverse ( self , head : Optional [ ListNode ], tail : Optional [ ListNode ]): last = head . next curr = last . next while curr != tail : last . next = curr . next curr . next = head . next head . next = curr curr = last . next return last const reverseKGroup = function ( head , k ) { if ( ! head || k === 1 ) { return head ; } dummy = new ListNode ( - 1 ); prev = dummy ; curr = head ; dummy . next = head ; for ( let i = 1 ; curr ; ++ i ) { if ( i % k === 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; }; const reverse = function ( head , tail ) { last = head . next ; curr = last . next ; while ( curr !== tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; }","title":"\u5be6\u4f5c"},{"location":"leetcode/reverse-nodes-in-k-group/#_4","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/roman-to-integer/","text":"0013. \u7f85\u99ac\u6578\u5b57\u8f49\u6574\u6578\uff08Roman to Integer\uff09 \u00b6 \u89e3\u7b54 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : int romanToInt ( string s ) { vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; int ans = 0 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans + roman [ s . back ()]; } }; class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) { ans -= roman [ s . charAt ( i ) ] ; } else { ans += roman [ s . charAt ( i ) ] ; } } return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } class Solution : def romanToInt ( self , s : str ) -> int : roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } ans = 0 for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]] const romanToInt = ( s ) => { const roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }; let ans = 0 for ( let i = 0 ; i < s . length ; ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0013. \u7f85\u99ac\u6578\u5b57\u8f49\u6574\u6578"},{"location":"leetcode/roman-to-integer/#0013-roman-to-integer","text":"","title":"0013. \u7f85\u99ac\u6578\u5b57\u8f49\u6574\u6578\uff08Roman to Integer\uff09"},{"location":"leetcode/roman-to-integer/#_1","text":"","title":"\u89e3\u7b54"},{"location":"leetcode/roman-to-integer/#_2","text":"C++ Java Python JavaScript class Solution { public : int romanToInt ( string s ) { vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; int ans = 0 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans + roman [ s . back ()]; } }; class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) { ans -= roman [ s . charAt ( i ) ] ; } else { ans += roman [ s . charAt ( i ) ] ; } } return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } class Solution : def romanToInt ( self , s : str ) -> int : roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } ans = 0 for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]] const romanToInt = ( s ) => { const roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }; let ans = 0 for ( let i = 0 ; i < s . length ; ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/roman-to-integer/#_3","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"leetcode/two-sum/","text":"Two Sum \u00b6 Problem \u00b6 Solution \u00b6 C++ Java Python class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"Two Sum"},{"location":"leetcode/two-sum/#two-sum","text":"","title":"Two Sum"},{"location":"leetcode/two-sum/#problem","text":"","title":"Problem"},{"location":"leetcode/two-sum/#solution","text":"C++ Java Python class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"Solution"},{"location":"leetcode/valid-anagram/","text":"0242. \u6709\u6548\u7684\u5b57\u6bcd\u7570\u4f4d\u8a5e\uff08Valid Anagram\uff09 \u00b6 \u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isAnagram ( string s , string t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t vector < int > count ( 128 ); for ( const char c : s ) { ++ count [ c ]; } for ( const char c : t ) { if ( -- count [ c ] < 0 ) return false ; } return true ; } }; class Solution { public boolean isAnagram ( String s , String t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) { ++ count [ c ] ; } for ( final char c : t . toCharArray ()) { if ( -- count [ c ] < 0 ) { return false ; } } return true ; } } from collections import Counter class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # anagram must have the same length if len ( s ) != len ( t ): return False # compare the number of each character in s and t return Counter ( s ) == Counter ( t ) const isAnagram = function ( s , t ) { // anagram must have the same length if ( s . length !== t . length ) { return false ; } // compare the number of each character in s and t const count = {}; for ( let i = 0 ; i < s . length ; ++ i ) { count [ s [ i ]] = ( count [ s [ i ]] || 0 ) + 1 ; } for ( let i = 0 ; i < t . length ; ++ i ) { if ( count [ t [ i ]]) { count [ t [ i ]] -= 1 ; } else { return false ; } } return true ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0242. \u6709\u6548\u7684\u5b57\u6bcd\u7570\u4f4d\u8a5e"},{"location":"leetcode/valid-anagram/#0242-valid-anagram","text":"","title":"0242. \u6709\u6548\u7684\u5b57\u6bcd\u7570\u4f4d\u8a5e\uff08Valid Anagram\uff09"},{"location":"leetcode/valid-anagram/#hash-mapping","text":"","title":"\u89e3\u7b54\uff1a\u96dc\u6e4a\u6620\u5c04\uff08Hash Mapping\uff09"},{"location":"leetcode/valid-anagram/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isAnagram ( string s , string t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t vector < int > count ( 128 ); for ( const char c : s ) { ++ count [ c ]; } for ( const char c : t ) { if ( -- count [ c ] < 0 ) return false ; } return true ; } }; class Solution { public boolean isAnagram ( String s , String t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) { ++ count [ c ] ; } for ( final char c : t . toCharArray ()) { if ( -- count [ c ] < 0 ) { return false ; } } return true ; } } from collections import Counter class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # anagram must have the same length if len ( s ) != len ( t ): return False # compare the number of each character in s and t return Counter ( s ) == Counter ( t ) const isAnagram = function ( s , t ) { // anagram must have the same length if ( s . length !== t . length ) { return false ; } // compare the number of each character in s and t const count = {}; for ( let i = 0 ; i < s . length ; ++ i ) { count [ s [ i ]] = ( count [ s [ i ]] || 0 ) + 1 ; } for ( let i = 0 ; i < t . length ; ++ i ) { if ( count [ t [ i ]]) { count [ t [ i ]] -= 1 ; } else { return false ; } } return true ; };","title":"\u5be6\u4f5c"},{"location":"leetcode/valid-anagram/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"patterns/0-or-1-knapsack/","text":"","title":"\u80cc\u5305\u554f\u984c"},{"location":"patterns/bitwise-xor/","text":"","title":"\u4f4d\u5143\u904b\u7b97"},{"location":"patterns/breadth-first-search/","text":"","title":"\u5ee3\u5ea6\u512a\u5148\u641c\u7d22"},{"location":"patterns/cyclic-sort/","text":"","title":"\u5faa\u74b0\u6392\u5e8f"},{"location":"patterns/depth-first-search/","text":"","title":"\u6df1\u5ea6\u512a\u5148\u641c\u7d22"},{"location":"patterns/fast-slow-pointers/","text":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u6982\u5ff5\u8aaa\u660e \u00b6 \u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u53c8\u7a31\u70ba Floyd \u5224\u5708\u6f14\u7b97\u6cd5\uff08Floyd Cycle Detection Algorithm\uff09\u6216\u9f9c\u5154\u8cfd\u8dd1\u7b97\u6cd5\uff08Tortoise and Hare Algorithm\uff09\uff0c\u4f7f\u7528\u5169\u500b\u6307\u91dd\u4ee5\u4e0d\u540c\u7684\u901f\u5ea6\u5728\u9663\u5217\u3001\u5e8f\u5217\u6216\u93c8\u7d50\u4e32\u5217\u4e2d\u79fb\u52d5\uff0c\u5169\u500b\u6307\u91dd\u5728\u4e00\u500b\u5faa\u74b0\u93c8\u7d50\u4e32\u5217\u4e2d\u5fc5\u7136\u6703\u76f8\u9047\u3002 \u7279\u5fb5\u898f\u5f8b \u00b6 \u93c8\u7d50\u4e32\u5217\u3001\u74b0\u5f62\u93c8\u7d50\u4e32\u5217\uff08cyclic linked-list\uff09\u3001\u74b0\u5f62\u9663\u5217\uff08cyclic array\uff09 \u5224\u65b7\u7dda\u6027\u7d50\u69cb\u7279\u5fb5\uff1a\u7372\u53d6\u93c8\u7d50\u4e32\u5217\u9577\u5ea6\u3001\u5224\u65b7\u662f\u5426\u6709\u74b0\u3001\u5224\u65b7\u662f\u5426\u4ea4\u932f \u547d\u540d\u898f\u7bc4 \u00b6 slow , fast walker , runner \u984c\u76ee\u6574\u7406 \u00b6 0141 Linked List Cycle 0142 Linked List Cycle II 0143 Recorder List 0202 Happy Number 0234 Palindrome Linked List 0457 Circular Array Loop 0876 Middle of the Linked List \u53c3\u8003\u8cc7\u6599 \u00b6 Cycle detection | WikiPedia","title":"\u5feb\u6162\u6307\u91dd"},{"location":"patterns/fast-slow-pointers/#fast-slow-pointers","text":"","title":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"patterns/fast-slow-pointers/#_1","text":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u53c8\u7a31\u70ba Floyd \u5224\u5708\u6f14\u7b97\u6cd5\uff08Floyd Cycle Detection Algorithm\uff09\u6216\u9f9c\u5154\u8cfd\u8dd1\u7b97\u6cd5\uff08Tortoise and Hare Algorithm\uff09\uff0c\u4f7f\u7528\u5169\u500b\u6307\u91dd\u4ee5\u4e0d\u540c\u7684\u901f\u5ea6\u5728\u9663\u5217\u3001\u5e8f\u5217\u6216\u93c8\u7d50\u4e32\u5217\u4e2d\u79fb\u52d5\uff0c\u5169\u500b\u6307\u91dd\u5728\u4e00\u500b\u5faa\u74b0\u93c8\u7d50\u4e32\u5217\u4e2d\u5fc5\u7136\u6703\u76f8\u9047\u3002","title":"\u6982\u5ff5\u8aaa\u660e"},{"location":"patterns/fast-slow-pointers/#_2","text":"\u93c8\u7d50\u4e32\u5217\u3001\u74b0\u5f62\u93c8\u7d50\u4e32\u5217\uff08cyclic linked-list\uff09\u3001\u74b0\u5f62\u9663\u5217\uff08cyclic array\uff09 \u5224\u65b7\u7dda\u6027\u7d50\u69cb\u7279\u5fb5\uff1a\u7372\u53d6\u93c8\u7d50\u4e32\u5217\u9577\u5ea6\u3001\u5224\u65b7\u662f\u5426\u6709\u74b0\u3001\u5224\u65b7\u662f\u5426\u4ea4\u932f","title":"\u7279\u5fb5\u898f\u5f8b"},{"location":"patterns/fast-slow-pointers/#_3","text":"slow , fast walker , runner","title":"\u547d\u540d\u898f\u7bc4"},{"location":"patterns/fast-slow-pointers/#_4","text":"0141 Linked List Cycle 0142 Linked List Cycle II 0143 Recorder List 0202 Happy Number 0234 Palindrome Linked List 0457 Circular Array Loop 0876 Middle of the Linked List","title":"\u984c\u76ee\u6574\u7406"},{"location":"patterns/fast-slow-pointers/#_5","text":"Cycle detection | WikiPedia","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"patterns/in-place-reversal-of-linked-list/","text":"","title":"In-place Reversal of Linked-List"},{"location":"patterns/k-way-merge/","text":"","title":"K-way Merge"},{"location":"patterns/merge-intervals/","text":"","title":"\u5408\u4f75\u5340\u9593"},{"location":"patterns/sliding-window/","text":"\u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09 \u00b6 \u6982\u5ff5\u8aaa\u660e \u00b6 \u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09 \u4ea6\u5373\u5728\u9663\u5217\u4e2d\u5efa\u7acb\u4e00\u500b\u53ef\u79fb\u52d5\u7684\u7bc4\u570d\uff0c\u4e26\u5728\u7bc4\u570d\u5167\u585e\u5165\u6eff\u8db3\u689d\u4ef6\u7684\u5143\u7d20\uff0c\u6bcf\u6b21\u5faa\u74b0\u4fbf\u5c07\u53f3\u6307\u91dd\u5411\u524d\u79fb\u52d5\uff0c\u4e26\u6839\u64da\u60c5\u6cc1\u79fb\u52d5\u5de6\u6307\u91dd\u3002 \u7279\u5fb5\u898f\u5f8b \u00b6 \u9663\u5217/\u5b57\u4e32 \u6700\u9577\u6216\u6700\u77ed\u9023\u7e8c \u984c\u76ee\u6574\u7406 \u00b6 0003 Longest Substring Without Repeating Characters 0030 Substring with Concatenation of All Words 0076 Minimum Window Substring 0209 Minimum Size Subarray Sum 0239 Sliding Window Maximum 0424 Longest Repeating Character Replacement 0904 Fruit into Baskets","title":"\u6ed1\u52d5\u7a97\u53e3"},{"location":"patterns/sliding-window/#sliding-window","text":"","title":"\u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09"},{"location":"patterns/sliding-window/#_1","text":"\u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09 \u4ea6\u5373\u5728\u9663\u5217\u4e2d\u5efa\u7acb\u4e00\u500b\u53ef\u79fb\u52d5\u7684\u7bc4\u570d\uff0c\u4e26\u5728\u7bc4\u570d\u5167\u585e\u5165\u6eff\u8db3\u689d\u4ef6\u7684\u5143\u7d20\uff0c\u6bcf\u6b21\u5faa\u74b0\u4fbf\u5c07\u53f3\u6307\u91dd\u5411\u524d\u79fb\u52d5\uff0c\u4e26\u6839\u64da\u60c5\u6cc1\u79fb\u52d5\u5de6\u6307\u91dd\u3002","title":"\u6982\u5ff5\u8aaa\u660e"},{"location":"patterns/sliding-window/#_2","text":"\u9663\u5217/\u5b57\u4e32 \u6700\u9577\u6216\u6700\u77ed\u9023\u7e8c","title":"\u7279\u5fb5\u898f\u5f8b"},{"location":"patterns/sliding-window/#_3","text":"0003 Longest Substring Without Repeating Characters 0030 Substring with Concatenation of All Words 0076 Minimum Window Substring 0209 Minimum Size Subarray Sum 0239 Sliding Window Maximum 0424 Longest Repeating Character Replacement 0904 Fruit into Baskets","title":"\u984c\u76ee\u6574\u7406"},{"location":"patterns/subsets%20copy/","text":"","title":"Subsets copy"},{"location":"patterns/subsets/","text":"","title":"Subsets"},{"location":"patterns/top-k-elements/","text":"","title":"Top K Elements"},{"location":"patterns/topological-sort/","text":"","title":"\u62d3\u58a3\u6392\u5e8f"},{"location":"patterns/two-heaps/","text":"","title":"Two Heaps"},{"location":"patterns/two-pointers/","text":"","title":"\u96d9\u5411\u6307\u91dd"},{"location":"en/","text":"","title":"Home"},{"location":"en/codility/BinaryGap/","text":"","title":"BinaryGap"},{"location":"en/codility/CyclicRotation/","text":"","title":"CyclicRotation"},{"location":"en/codility/FloodDepth/","text":"","title":"FloodDepth"},{"location":"en/codility/LongestPassword/","text":"","title":"LongestPassword"},{"location":"en/codility/OddOccurrencesInArray/","text":"","title":"OddOccurrencesInArray"},{"location":"en/codility/PrefixSet/","text":"","title":"PrefixSet"},{"location":"en/intro/","text":"Online Judge Note \ud83d\udcdd Solutions and notes of the problems on online judge platforms like LeetCode, Codility and HackerRank. Branches \u00b6 There are a three branches for difference usage here: main holds the README and License. docs stores the source code of this site . gh-pages hosts the website pages published by GitHub Actions (check the workflow file ). Quick Start \u00b6 # clone the project and checkout to 'docs' branch $ git clone https://github.com/Hsins/OJ-Note $ cd OJ-Note && git checkout docs # create the virtual environment $ python3 -m venv env # activate the virtual environment $ source env/bin/activate # Unix-like $ . \\e nv \\S cripts \\A ctivate.ps1 # Windows # install dependencies $ pip install -r requirements.txt # start the server $ mkdocs serve Related Repositories \u00b6 Hsins/Codility | GitHub Hsins/HackerRank | GitHub Hsins/LeetCode | GitHub License \u00b6 Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"About"},{"location":"en/intro/#branches","text":"There are a three branches for difference usage here: main holds the README and License. docs stores the source code of this site . gh-pages hosts the website pages published by GitHub Actions (check the workflow file ).","title":"Branches"},{"location":"en/intro/#quick-start","text":"# clone the project and checkout to 'docs' branch $ git clone https://github.com/Hsins/OJ-Note $ cd OJ-Note && git checkout docs # create the virtual environment $ python3 -m venv env # activate the virtual environment $ source env/bin/activate # Unix-like $ . \\e nv \\S cripts \\A ctivate.ps1 # Windows # install dependencies $ pip install -r requirements.txt # start the server $ mkdocs serve","title":"Quick Start"},{"location":"en/intro/#related-repositories","text":"Hsins/Codility | GitHub Hsins/HackerRank | GitHub Hsins/LeetCode | GitHub","title":"Related Repositories"},{"location":"en/intro/#license","text":"Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"License"},{"location":"en/intro/patterns/","text":"Two Pointers \u00b6 Fast/Slow Pointers \u00b6 Merge Intervals \u00b6 Cyclic Sort \u00b6 In-place Reversal of Linked-List \u00b6 Breadth First Search \u00b6 Depth First Search \u00b6 Two Heaps \u00b6 Subsets \u00b6 Modified Binary Search \u00b6 Bitwise XOR \u00b6 Top K Elements \u00b6 K-way Merge \u00b6 0 or 1 Knapsack \u00b6 Topological Sort \u00b6","title":"Patterns"},{"location":"en/intro/patterns/#two-pointers","text":"","title":"Two Pointers"},{"location":"en/intro/patterns/#fastslow-pointers","text":"","title":"Fast/Slow Pointers"},{"location":"en/intro/patterns/#merge-intervals","text":"","title":"Merge Intervals"},{"location":"en/intro/patterns/#cyclic-sort","text":"","title":"Cyclic Sort"},{"location":"en/intro/patterns/#in-place-reversal-of-linked-list","text":"","title":"In-place Reversal of Linked-List"},{"location":"en/intro/patterns/#breadth-first-search","text":"","title":"Breadth First Search"},{"location":"en/intro/patterns/#depth-first-search","text":"","title":"Depth First Search"},{"location":"en/intro/patterns/#two-heaps","text":"","title":"Two Heaps"},{"location":"en/intro/patterns/#subsets","text":"","title":"Subsets"},{"location":"en/intro/patterns/#modified-binary-search","text":"","title":"Modified Binary Search"},{"location":"en/intro/patterns/#bitwise-xor","text":"","title":"Bitwise XOR"},{"location":"en/intro/patterns/#top-k-elements","text":"","title":"Top K Elements"},{"location":"en/intro/patterns/#k-way-merge","text":"","title":"K-way Merge"},{"location":"en/intro/patterns/#0-or-1-knapsack","text":"","title":"0 or 1 Knapsack"},{"location":"en/intro/patterns/#topological-sort","text":"","title":"Topological Sort"},{"location":"en/intro/references/","text":"\u8cc7\u6599\u7d50\u69cb\u8207\u6f14\u7b97\u6cd5\uff1aLeetCode/LintCode \u984c\u89e3 | Billryan LeetCode All in One \u984c\u76ee\u8b1b\u89e3\u5f59\u7e3d | GrandYang","title":"References"},{"location":"en/intro/styleguide/","text":"Fundamental \u00b6 Rules \u00b6 Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD) Examples \u00b6 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template \u00b6 Rules \u00b6 There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each variable. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels, each separating a blank line between kernels, but each kernel itself should not be blank in between. return private private variables private function(s) Schematic Template \u00b6 Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; // single line based on clang-format vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { // use `map.count` rather than `map.find` pattern int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; Boundary Conditions \u00b6 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value \u00b6 return ans ; return {}; Data Structure \u00b6 // C++ unordered_set < string > set ; unordered_map < char , int > map ; vector < int > map ; // even if you use array or vector, stick to map queue < TreeNode *> queue ; deque < TreeNode *> deque ; stack < char > stack ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; # Python set_ = set () # or wordSet = set() if you like dict = {} dict = collections . defaultdict ( int ) dict = collections . defaultdict ( list ) queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = [] Two Pointers / Sliding Windows \u00b6 Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) { ... } int l = 0 ; int r = nums . size () - 1 ; Binary Search \u00b6 Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode \u00b6 ListNode dummy ( 0 ); // the only variable that declared statically ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings \u00b6 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing \u00b6 // vector<int> nums; for ( int i = 0 ; i < nums . size (); i ++ ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); i ++ ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... } Pattern \u00b6 Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) length ++ ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; Others \u00b6 Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. int currNum ; TreeNode * currNode ; int maxProfit ; Add a underline ( _ ) after a variable. When there's confliction in expression and function: // C++ min , max , std :: min (), std :: max () # Python min_ , max_ , min (), max () When there's confliction with default reserved words: # Python set_ , set () When there are two maps/stacks, use 1 and 2 suffixes. unordered_map < char , int > map1 ; unordered_map < char , int > map2 ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . const is used iff we get value of size() or length() . auto is used iff when we iterate through a map or declare a variable of ListNode* (except NULL ). Use & whenever possible except int and char . Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Style Guide"},{"location":"en/intro/styleguide/#fundamental","text":"","title":"Fundamental"},{"location":"en/intro/styleguide/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD)","title":"Rules"},{"location":"en/intro/styleguide/#examples","text":"// Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"en/intro/styleguide/#template","text":"","title":"Template"},{"location":"en/intro/styleguide/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each variable. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels, each separating a blank line between kernels, but each kernel itself should not be blank in between. return private private variables private function(s)","title":"Rules"},{"location":"en/intro/styleguide/#schematic-template","text":"Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; // single line based on clang-format vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( A [ k ] - A [ j ] < A [ j ] && map . count ( A [ k ] - A [ j ])) { // use `map.count` rather than `map.find` pattern int i = map [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } };","title":"Schematic Template"},{"location":"en/intro/styleguide/#boundary-conditions","text":"// Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"en/intro/styleguide/#return-value","text":"return ans ; return {};","title":"Return Value"},{"location":"en/intro/styleguide/#data-structure","text":"// C++ unordered_set < string > set ; unordered_map < char , int > map ; vector < int > map ; // even if you use array or vector, stick to map queue < TreeNode *> queue ; deque < TreeNode *> deque ; stack < char > stack ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; # Python set_ = set () # or wordSet = set() if you like dict = {} dict = collections . defaultdict ( int ) dict = collections . defaultdict ( list ) queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = []","title":"Data Structure"},{"location":"en/intro/styleguide/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) { ... } int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"en/intro/styleguide/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"en/intro/styleguide/#listnode","text":"ListNode dummy ( 0 ); // the only variable that declared statically ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"en/intro/styleguide/#2d-vector-2-strings","text":"// 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"en/intro/styleguide/#traversing","text":"// vector<int> nums; for ( int i = 0 ; i < nums . size (); i ++ ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); i ++ ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"en/intro/styleguide/#pattern","text":"Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) length ++ ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ;","title":"Pattern"},{"location":"en/intro/styleguide/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. int currNum ; TreeNode * currNode ; int maxProfit ; Add a underline ( _ ) after a variable. When there's confliction in expression and function: // C++ min , max , std :: min (), std :: max () # Python min_ , max_ , min (), max () When there's confliction with default reserved words: # Python set_ , set () When there are two maps/stacks, use 1 and 2 suffixes. unordered_map < char , int > map1 ; unordered_map < char , int > map2 ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . const is used iff we get value of size() or length() . auto is used iff when we iterate through a map or declare a variable of ListNode* (except NULL ). Use & whenever possible except int and char . Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Others"},{"location":"en/leetcode/circular-array-loop/","text":"0457. Circular Array Loop \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { const int n = nums . size (); if ( n < 2 ) { return false ; } auto advance = [ & ]( int i ) { const int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) { return false ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; final int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False const circularArrayLoop = ( nums ) => { if ( nums . length < 2 ) { return false ; } for ( let i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] === 0 ) { continue ; } let slow = i ; let fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow === fast ) { if ( slow === advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; const sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; }; const advance = ( nums , i ) => { const n = nums . length ; const val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0457. Circular Array Loop"},{"location":"en/leetcode/circular-array-loop/#0457-circular-array-loop","text":"","title":"0457. Circular Array Loop"},{"location":"en/leetcode/circular-array-loop/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/circular-array-loop/#_1","text":"C++ Java Python JavaScript class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { const int n = nums . size (); if ( n < 2 ) { return false ; } auto advance = [ & ]( int i ) { const int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) { return false ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { continue ; } int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; final int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False const circularArrayLoop = ( nums ) => { if ( nums . length < 2 ) { return false ; } for ( let i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] === 0 ) { continue ; } let slow = i ; let fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow === fast ) { if ( slow === advance ( nums , slow )) { break ; } return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; const sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; }; const advance = ( nums , i ) => { const n = nums . length ; const val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }","title":"\u5be6\u4f5c"},{"location":"en/leetcode/circular-array-loop/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/contains-duplicate/","text":"0217. Contains Duplicate \u00b6 Solution: Presorting \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { // presorting sort ( nums . begin (), nums . end ()); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . size () - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ]) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { // presorting Arrays . sort ( nums ); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : # presorting nums . sort () # check if there are duplicates by comparing adjacent elements for i in range ( len ( nums ) - 1 ): if nums [ i ] == nums [ i + 1 ]: return True return False const containsDuplicate = function ( nums ) { // presorting nums . sort (( a , b ) => a - b ); // check if there are duplicates by comparing adjacent elements for ( let i = 0 ; i < nums . length - 1 ; ++ i ) { if ( nums [ i ] === nums [ i + 1 ]) { return true ; } } return false ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n \\log{} n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{} n)\\) Solution: Hash Mapping \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) { if ( ! seen . insert ( num ). second ) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) { if ( ! seen . add ( num )) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) const containsDuplicate = function ( nums ) { const seen = new Set (); for ( const num of nums ) { if ( seen . has ( num )) { return true ; } seen . add ( num ); } return false ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"0217. Contains Duplicate"},{"location":"en/leetcode/contains-duplicate/#0217-contains-duplicate","text":"","title":"0217. Contains Duplicate"},{"location":"en/leetcode/contains-duplicate/#solution-presorting","text":"","title":"Solution: Presorting"},{"location":"en/leetcode/contains-duplicate/#code","text":"C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { // presorting sort ( nums . begin (), nums . end ()); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . size () - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ]) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { // presorting Arrays . sort ( nums ); // check if there are duplicates by comparing adjacent elements for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] == nums [ i + 1 ] ) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : # presorting nums . sort () # check if there are duplicates by comparing adjacent elements for i in range ( len ( nums ) - 1 ): if nums [ i ] == nums [ i + 1 ]: return True return False const containsDuplicate = function ( nums ) { // presorting nums . sort (( a , b ) => a - b ); // check if there are duplicates by comparing adjacent elements for ( let i = 0 ; i < nums . length - 1 ; ++ i ) { if ( nums [ i ] === nums [ i + 1 ]) { return true ; } } return false ; };","title":"Code"},{"location":"en/leetcode/contains-duplicate/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n \\log{} n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{} n)\\)","title":"Analysis"},{"location":"en/leetcode/contains-duplicate/#solution-hash-mapping","text":"","title":"Solution: Hash Mapping"},{"location":"en/leetcode/contains-duplicate/#code_1","text":"C++ Java Python JavaScript class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) { if ( ! seen . insert ( num ). second ) { return true ; } } return false ; } }; class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) { if ( ! seen . add ( num )) { return true ; } } return false ; } } class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) const containsDuplicate = function ( nums ) { const seen = new Set (); for ( const num of nums ) { if ( seen . has ( num )) { return true ; } seen . add ( num ); } return false ; };","title":"Code"},{"location":"en/leetcode/contains-duplicate/#analysis_1","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"Analysis"},{"location":"en/leetcode/happy-number/","text":"0202. Happy Number \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private : int sumSquare ( int num ) { int sum = 0 ; while ( num ) { sum += pow ( num % 10 , 2 ); num /= 10 ; } return sum ; } }; class Solution { public boolean isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private int sumSquare ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } class Solution : def isHappy ( self , num : int ) -> bool : def calculate_square_sum ( num ): res = 0 while num : digit = num % 10 res = res + digit * digit num = num // 10 return res slow = calculate_square_sum ( num ) fast = calculate_square_sum ( calculate_square_sum ( num )) while slow != fast : slow = calculate_square_sum ( slow ) fast = calculate_square_sum ( calculate_square_sum ( fast )) return slow == 1 const isHappy = ( num ) => { let slow = sumSquare ( num ); let fast = sumSquare ( sumSquare ( num )); while ( slow !== fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow === 1 ; }; const sumSquare = ( num ) => { let sum = 0 ; while ( num ) { sum = sum + Math . pow ( num % 10 , 2 ); num = Math . floor ( num / 10 ); } return sum ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{n})\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0202. Happy Number"},{"location":"en/leetcode/happy-number/#0202-happy-number","text":"","title":"0202. Happy Number"},{"location":"en/leetcode/happy-number/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/happy-number/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private : int sumSquare ( int num ) { int sum = 0 ; while ( num ) { sum += pow ( num % 10 , 2 ); num /= 10 ; } return sum ; } }; class Solution { public boolean isHappy ( int num ) { int slow = sumSquare ( num ); int fast = sumSquare ( sumSquare ( num )); while ( slow != fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow == 1 ; } private int sumSquare ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } class Solution : def isHappy ( self , num : int ) -> bool : def calculate_square_sum ( num ): res = 0 while num : digit = num % 10 res = res + digit * digit num = num // 10 return res slow = calculate_square_sum ( num ) fast = calculate_square_sum ( calculate_square_sum ( num )) while slow != fast : slow = calculate_square_sum ( slow ) fast = calculate_square_sum ( calculate_square_sum ( fast )) return slow == 1 const isHappy = ( num ) => { let slow = sumSquare ( num ); let fast = sumSquare ( sumSquare ( num )); while ( slow !== fast ) { slow = sumSquare ( slow ); fast = sumSquare ( sumSquare ( fast )); } return slow === 1 ; }; const sumSquare = ( num ) => { let sum = 0 ; while ( num ) { sum = sum + Math . pow ( num % 10 , 2 ); num = Math . floor ( num / 10 ); } return sum ; };","title":"\u5be6\u4f5c"},{"location":"en/leetcode/happy-number/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(\\log{n})\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/insomorphic-strings/","text":"0205. Isomorphic Strings \u00b6 Solution: Hash Mapping \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) { return false ; } } return true ; } } class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )] const isIsomorphic = function ( s , t ) { const charToIndex_s = {}; const charToIndex_t = {}; for ( let i = 0 ; i < s . length ; ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0205. Insomorphic Strings"},{"location":"en/leetcode/insomorphic-strings/#0205-isomorphic-strings","text":"","title":"0205. Isomorphic Strings"},{"location":"en/leetcode/insomorphic-strings/#solution-hash-mapping","text":"","title":"Solution: Hash Mapping"},{"location":"en/leetcode/insomorphic-strings/#code","text":"C++ Java Python JavaScript class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) { return false ; } } return true ; } } class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )] const isIsomorphic = function ( s , t ) { const charToIndex_s = {}; const charToIndex_t = {}; for ( let i = 0 ; i < s . length ; ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) { return false ; } charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; };","title":"Code"},{"location":"en/leetcode/insomorphic-strings/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/intersection-of-two-linked-lists/","text":"0160. Intersection of Two Linked Lists \u00b6 Solution: Two Pointers \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : # both linked-list are empty if not headA or not headB : return None a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a const getIntersectionNode = function ( headA , headB ) { // both linked-list are empty if ( ! headA || ! headB ) { return null ; } let a = headA ; let b = headB ; while ( a !== b ) { a = a ? a . next : headB ; b = b ? b . next : headA ; } return a ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(a + b)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0160. Intersection of Two Linked Lists"},{"location":"en/leetcode/intersection-of-two-linked-lists/#0160-intersection-of-two-linked-lists","text":"","title":"0160. Intersection of Two Linked Lists"},{"location":"en/leetcode/intersection-of-two-linked-lists/#solution-two-pointers","text":"","title":"Solution: Two Pointers"},{"location":"en/leetcode/intersection-of-two-linked-lists/#code","text":"C++ Java Python JavaScript class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : # both linked-list are empty if not headA or not headB : return None a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a const getIntersectionNode = function ( headA , headB ) { // both linked-list are empty if ( ! headA || ! headB ) { return null ; } let a = headA ; let b = headB ; while ( a !== b ) { a = a ? a . next : headB ; b = b ? b . next : headA ; } return a ; };","title":"Code"},{"location":"en/leetcode/intersection-of-two-linked-lists/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(a + b)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/linked-list-cycle-ii/","text":"0142. Linked List Cycle II \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } class Solution : def detectCycle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None const detectCycle = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; if ( slow === fast ) { slow = head ; while ( slow !== fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0142. \u74b0\u5f62\u93c8\u8868 II"},{"location":"en/leetcode/linked-list-cycle-ii/#0142-linked-list-cycle-ii","text":"","title":"0142. Linked List Cycle II"},{"location":"en/leetcode/linked-list-cycle-ii/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/linked-list-cycle-ii/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } class Solution : def detectCycle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None const detectCycle = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; if ( slow === fast ) { slow = head ; while ( slow !== fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; };","title":"\u5be6\u4f5c"},{"location":"en/leetcode/linked-list-cycle-ii/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/linked-list-cycle/","text":"0141. Linked List Cycle \u00b6 Solution: Fast-slow Pointers \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { return true ; } } return false ; } } class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : \u3000 # empty linked-list or linked-list with only one node if not head or not head . next : return False # initialize slow and fast pointers slow = head fast = head # move fast pointer two nodes at a time while fast and fast . next : slow = slow . next fast = fast . next . next # if fast pointer ever meets the slow pointer, there is a cycle if slow == fast : return True return False const hasCycle = function ( head ) { // empty linked-list or linked-list with only one node if ( ! head || ! head . next ) { return false ; } // initialize slow and fast pointers let slow = head ; let fast = head ; // move fast pointer two nodes at a time while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; // if fast pointer ever meets the slow pointer, there is a cycle if ( slow === fast ) { return true ; } } return false ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0141. Linked List Cycle"},{"location":"en/leetcode/linked-list-cycle/#0141-linked-list-cycle","text":"","title":"0141. Linked List Cycle"},{"location":"en/leetcode/linked-list-cycle/#solution-fast-slow-pointers","text":"","title":"Solution: Fast-slow Pointers"},{"location":"en/leetcode/linked-list-cycle/#code","text":"C++ Java Python JavaScript class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { return true ; } } return false ; } } class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : \u3000 # empty linked-list or linked-list with only one node if not head or not head . next : return False # initialize slow and fast pointers slow = head fast = head # move fast pointer two nodes at a time while fast and fast . next : slow = slow . next fast = fast . next . next # if fast pointer ever meets the slow pointer, there is a cycle if slow == fast : return True return False const hasCycle = function ( head ) { // empty linked-list or linked-list with only one node if ( ! head || ! head . next ) { return false ; } // initialize slow and fast pointers let slow = head ; let fast = head ; // move fast pointer two nodes at a time while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; // if fast pointer ever meets the slow pointer, there is a cycle if ( slow === fast ) { return true ; } } return false ; };","title":"Code"},{"location":"en/leetcode/linked-list-cycle/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/merge-two-sorted-lists/","text":"0021. Merge Two Sorted Lists \u00b6 Solution: Recursion \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 -> val > list2 -> val ) { swap ( list1 , list2 ); } list1 -> next = mergeTwoLists ( list1 -> next , list2 ); return list1 ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { if ( list1 == null || list2 == null ) return list1 == null ? list2 : list1 ; if ( list1 . val > list2 . val ) { ListNode temp = list1 ; list1 = list2 ; list2 = temp ; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return l1 ; } } class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: if not list1 or not list2 : return list1 if list1 else list2 if list1 . val > list2 . val : list1 , list2 = list2 , list1 list1 . next = self . mergeTwoLists ( list1 . next , list2 ) return list1 const mergeTwoLists = function ( list1 , list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 . val > list2 . val ) { [ list1 , list2 ] = [ list2 , list1 ]; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) Solution: Iteration \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { ListNode * dummy = new ListNode ( NULL ); ListNode * tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 -> val < list2 -> val ) { tail -> next = list1 ; list1 = list1 -> next ; } else { tail -> next = list2 ; list2 = list2 -> next ; } tail = tail -> next ; } // append rest link-list tail -> next = list1 == nullptr ? list2 : list1 ; return dummy -> next ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode ( - 1 ); ListNode tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 != null && list2 != null ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 == null ? list2 : list1 ; return dummy . next ; } }; class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: dummy = ListNode ( - 1 ) tail = dummy # both linked-list are not empty, compare and append the smaller value while list1 and list2 : if list1 . val <= list2 . val : tail . next = list1 list1 = list1 . next else : tail . next = list2 list2 = list2 . next tail = tail . next # append rest link-list tail . next = list1 if list1 else list2 return dummy . next const mergeTwoLists = function ( list1 , list2 ) { const dummy = new ListNode ( - 1 ); let tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 ? list1 : list2 ; return dummy . next ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(1)\\)","title":"0021. Merge Two Sorted Lists"},{"location":"en/leetcode/merge-two-sorted-lists/#0021-merge-two-sorted-lists","text":"","title":"0021. Merge Two Sorted Lists"},{"location":"en/leetcode/merge-two-sorted-lists/#solution-recursion","text":"","title":"Solution: Recursion"},{"location":"en/leetcode/merge-two-sorted-lists/#code","text":"C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 -> val > list2 -> val ) { swap ( list1 , list2 ); } list1 -> next = mergeTwoLists ( list1 -> next , list2 ); return list1 ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { if ( list1 == null || list2 == null ) return list1 == null ? list2 : list1 ; if ( list1 . val > list2 . val ) { ListNode temp = list1 ; list1 = list2 ; list2 = temp ; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return l1 ; } } class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: if not list1 or not list2 : return list1 if list1 else list2 if list1 . val > list2 . val : list1 , list2 = list2 , list1 list1 . next = self . mergeTwoLists ( list1 . next , list2 ) return list1 const mergeTwoLists = function ( list1 , list2 ) { if ( ! list1 || ! list2 ) { return list1 ? list1 : list2 ; } if ( list1 . val > list2 . val ) { [ list1 , list2 ] = [ list2 , list1 ]; } list1 . next = mergeTwoLists ( list1 . next , list2 ); return list1 ; };","title":"Code"},{"location":"en/leetcode/merge-two-sorted-lists/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\)","title":"Analysis"},{"location":"en/leetcode/merge-two-sorted-lists/#solution-iteration","text":"","title":"Solution: Iteration"},{"location":"en/leetcode/merge-two-sorted-lists/#code_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { ListNode * dummy = new ListNode ( NULL ); ListNode * tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 -> val < list2 -> val ) { tail -> next = list1 ; list1 = list1 -> next ; } else { tail -> next = list2 ; list2 = list2 -> next ; } tail = tail -> next ; } // append rest link-list tail -> next = list1 == nullptr ? list2 : list1 ; return dummy -> next ; } }; class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { ListNode dummy = new ListNode ( - 1 ); ListNode tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 != null && list2 != null ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 == null ? list2 : list1 ; return dummy . next ; } }; class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: dummy = ListNode ( - 1 ) tail = dummy # both linked-list are not empty, compare and append the smaller value while list1 and list2 : if list1 . val <= list2 . val : tail . next = list1 list1 = list1 . next else : tail . next = list2 list2 = list2 . next tail = tail . next # append rest link-list tail . next = list1 if list1 else list2 return dummy . next const mergeTwoLists = function ( list1 , list2 ) { const dummy = new ListNode ( - 1 ); let tail = dummy ; // both linked-list are not empty, compare and append the smaller value while ( list1 && list2 ) { if ( list1 . val <= list2 . val ) { tail . next = list1 ; list1 = list1 . next ; } else { tail . next = list2 ; list2 = list2 . next ; } tail = tail . next ; } // append rest link-list tail . next = list1 ? list1 : list2 ; return dummy . next ; };","title":"Code"},{"location":"en/leetcode/merge-two-sorted-lists/#analysis_1","text":"\u6642\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(n + m)\\) \u7a7a\u9593\u8907\u96dc\u5ea6 \uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/middle-of-the-linked-list/","text":"0876. Middle of the Linked List \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } class Solution : def middleNode ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow const middleNode = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } return slow ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0876. Middle of the Linked List"},{"location":"en/leetcode/middle-of-the-linked-list/#0876-middle-of-the-linked-list","text":"","title":"0876. Middle of the Linked List"},{"location":"en/leetcode/middle-of-the-linked-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/middle-of-the-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } class Solution : def middleNode ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow const middleNode = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } return slow ; };","title":"\u5be6\u4f5c"},{"location":"en/leetcode/middle-of-the-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/palindrome-linked-list/","text":"0234. Palindrome Linked List \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) { slow = slow -> next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) { return false ; } slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True const isPalindrome = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } if ( fast ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow . val !== head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; }; const reverseList = ( head ) => { let prev = null ; while ( head != null ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0234. Palindrome Linked List"},{"location":"en/leetcode/palindrome-linked-list/#0234-palindrome-linked-list","text":"","title":"0234. Palindrome Linked List"},{"location":"en/leetcode/palindrome-linked-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/palindrome-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) { slow = slow -> next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) { return false ; } slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True const isPalindrome = ( head ) => { let slow = head ; let fast = head ; while ( fast && fast . next ) { slow = slow . next ; fast = fast . next . next ; } if ( fast ) { slow = slow . next ; } slow = reverseList ( slow ); while ( slow ) { if ( slow . val !== head . val ) { return false ; } slow = slow . next ; head = head . next ; } return true ; }; const reverseList = ( head ) => { let prev = null ; while ( head != null ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; }","title":"\u5be6\u4f5c"},{"location":"en/leetcode/palindrome-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/reorder-list/","text":"0143. Reorder List \u00b6 \u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } class Solution : def reorderList ( self , head : Optional [ ListNode ]) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed ) const reorderList = ( head ) => { if ( ! head || ! head . next ) { return ; } const mid = findMid ( head ); const reversed = reverse ( mid ); merge ( head , reversed ); }; const findMid = ( head ) => { let prev = null ; let slow = head ; let fast = slow ; while ( fast && fast . next ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } const reverse = ( head ) => { let prev = null ; let curr = head ; while ( curr ) { const next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } const merge = ( list1 , list2 ) => { while ( list2 ) { const next = list1 . next ; list1 . next = list2 ; list1 = list2 ; list2 = next ; } } \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0143. Reorder List"},{"location":"en/leetcode/reorder-list/#0143-reorder-list","text":"","title":"0143. Reorder List"},{"location":"en/leetcode/reorder-list/#fast-slow-pointers","text":"","title":"\u89e3\u7b54\uff1a\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/leetcode/reorder-list/#_1","text":"C++ Java Python JavaScript class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } class Solution : def reorderList ( self , head : Optional [ ListNode ]) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed ) const reorderList = ( head ) => { if ( ! head || ! head . next ) { return ; } const mid = findMid ( head ); const reversed = reverse ( mid ); merge ( head , reversed ); }; const findMid = ( head ) => { let prev = null ; let slow = head ; let fast = slow ; while ( fast && fast . next ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } const reverse = ( head ) => { let prev = null ; let curr = head ; while ( curr ) { const next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } const merge = ( list1 , list2 ) => { while ( list2 ) { const next = list1 . next ; list1 . next = list2 ; list1 = list2 ; list2 = next ; } }","title":"\u5be6\u4f5c"},{"location":"en/leetcode/reorder-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/reverse-linked-list/","text":"0206. Reverse Linked List \u00b6 \u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode * newHead = reverseList ( head -> next ); head -> next -> next = head ; head -> next = nullptr ; return newHead ; } }; class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if not head or not head . next : return head newHead = self . reverseList ( head . next ) head . next . next = head head . next = None return newHead const reverseList = ( head ) => { if ( ! head || ! head . next ) { return head ; } const newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iterative\uff09 \u00b6 \u5be6\u4f5c \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev const reverseList = ( head ) => { let prev = null ; while ( head ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; }; \u5206\u6790 \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0206. Reverse Linked List"},{"location":"en/leetcode/reverse-linked-list/#0206-reverse-linked-list","text":"","title":"0206. Reverse Linked List"},{"location":"en/leetcode/reverse-linked-list/#recursion","text":"","title":"\u89e3\u7b54\uff1a\u905e\u8ff4\uff08Recursion\uff09"},{"location":"en/leetcode/reverse-linked-list/#_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode * newHead = reverseList ( head -> next ); head -> next -> next = head ; head -> next = nullptr ; return newHead ; } }; class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: if not head or not head . next : return head newHead = self . reverseList ( head . next ) head . next . next = head head . next = None return newHead const reverseList = ( head ) => { if ( ! head || ! head . next ) { return head ; } const newHead = reverseList ( head . next ); head . next . next = head ; head . next = null ; return newHead ; };","title":"\u5be6\u4f5c"},{"location":"en/leetcode/reverse-linked-list/#_2","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/reverse-linked-list/#iterative","text":"","title":"\u89e3\u7b54\uff1a\u8fed\u4ee3\uff08Iterative\uff09"},{"location":"en/leetcode/reverse-linked-list/#_3","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev const reverseList = ( head ) => { let prev = null ; while ( head ) { const next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; };","title":"\u5be6\u4f5c"},{"location":"en/leetcode/reverse-linked-list/#_4","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"\u5206\u6790"},{"location":"en/leetcode/reverse-nodes-in-k-group/","text":"0025. Reverse Nodes in k-Group \u00b6 Solution: Recursion \u00b6 Code \u00b6 Analysis \u00b6 Solution: Iteration \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) { return head ; } ListNode * dummy = new ListNode ( -1 ); ListNode * prev = dummy ; ListNode * curr = head ; dummy -> next = head ; for ( int i = 1 ; curr ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr -> next ); curr = prev -> next ; } else { curr = curr -> next ; } } return dummy -> next ; } ListNode * reverse ( ListNode * head , ListNode * tail ) { ListNode * last = head -> next ; ListNode * curr = last -> next ; while ( curr != tail ) { last -> next = curr -> next ; curr -> next = head -> next ; head -> next = curr ; curr = last -> next ; } return last ; } }; class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) { return head ; } ListNode dummy = new ListNode ( - 1 ); ListNode prev = dummy ; ListNode curr = head ; dummy . next = head ; for ( int i = 1 ; curr != null ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; } private ListNode reverse ( ListNode head , ListNode tail ) { ListNode last = head . next ; ListNode curr = last . next ; while ( curr != tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } } class Solution : def reverseKGroup ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: if not head or k == 1 : return head dummy = ListNode () prev = dummy curr = head dummy . next = head idx = 1 while curr : if idx % k == 0 : prev = self . reverse ( prev , curr . next ) curr = prev . next else : curr = curr . next idx += 1 return dummy . next def reverse ( self , head : Optional [ ListNode ], tail : Optional [ ListNode ]): last = head . next curr = last . next while curr != tail : last . next = curr . next curr . next = head . next head . next = curr curr = last . next return last const reverseKGroup = ( head , k ) => { if ( ! head || k === 1 ) { return head ; } dummy = new ListNode ( - 1 ); prev = dummy ; curr = head ; dummy . next = head ; for ( let i = 1 ; curr ; ++ i ) { if ( i % k === 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; }; const reverse = ( head , tail ) => { last = head . next ; curr = last . next ; while ( curr !== tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0025. Reverse Nodes in k-Group"},{"location":"en/leetcode/reverse-nodes-in-k-group/#0025-reverse-nodes-in-k-group","text":"","title":"0025. Reverse Nodes in k-Group"},{"location":"en/leetcode/reverse-nodes-in-k-group/#solution-recursion","text":"","title":"Solution: Recursion"},{"location":"en/leetcode/reverse-nodes-in-k-group/#code","text":"","title":"Code"},{"location":"en/leetcode/reverse-nodes-in-k-group/#analysis","text":"","title":"Analysis"},{"location":"en/leetcode/reverse-nodes-in-k-group/#solution-iteration","text":"","title":"Solution: Iteration"},{"location":"en/leetcode/reverse-nodes-in-k-group/#code_1","text":"C++ Java Python JavaScript class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) { return head ; } ListNode * dummy = new ListNode ( -1 ); ListNode * prev = dummy ; ListNode * curr = head ; dummy -> next = head ; for ( int i = 1 ; curr ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr -> next ); curr = prev -> next ; } else { curr = curr -> next ; } } return dummy -> next ; } ListNode * reverse ( ListNode * head , ListNode * tail ) { ListNode * last = head -> next ; ListNode * curr = last -> next ; while ( curr != tail ) { last -> next = curr -> next ; curr -> next = head -> next ; head -> next = curr ; curr = last -> next ; } return last ; } }; class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) { return head ; } ListNode dummy = new ListNode ( - 1 ); ListNode prev = dummy ; ListNode curr = head ; dummy . next = head ; for ( int i = 1 ; curr != null ; ++ i ) { if ( i % k == 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; } private ListNode reverse ( ListNode head , ListNode tail ) { ListNode last = head . next ; ListNode curr = last . next ; while ( curr != tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; } } class Solution : def reverseKGroup ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: if not head or k == 1 : return head dummy = ListNode () prev = dummy curr = head dummy . next = head idx = 1 while curr : if idx % k == 0 : prev = self . reverse ( prev , curr . next ) curr = prev . next else : curr = curr . next idx += 1 return dummy . next def reverse ( self , head : Optional [ ListNode ], tail : Optional [ ListNode ]): last = head . next curr = last . next while curr != tail : last . next = curr . next curr . next = head . next head . next = curr curr = last . next return last const reverseKGroup = ( head , k ) => { if ( ! head || k === 1 ) { return head ; } dummy = new ListNode ( - 1 ); prev = dummy ; curr = head ; dummy . next = head ; for ( let i = 1 ; curr ; ++ i ) { if ( i % k === 0 ) { prev = reverse ( prev , curr . next ); curr = prev . next ; } else { curr = curr . next ; } } return dummy . next ; }; const reverse = ( head , tail ) => { last = head . next ; curr = last . next ; while ( curr !== tail ) { last . next = curr . next ; curr . next = head . next ; head . next = curr ; curr = last . next ; } return last ; }","title":"Code"},{"location":"en/leetcode/reverse-nodes-in-k-group/#analysis_1","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/roman-to-integer/","text":"0013. Roman to Integer \u00b6 Solutions \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : int romanToInt ( string s ) { vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; int ans = 0 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans + roman [ s . back ()]; } }; class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) { ans -= roman [ s . charAt ( i ) ] ; } else { ans += roman [ s . charAt ( i ) ] ; } } return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } class Solution : def romanToInt ( self , s : str ) -> int : roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } ans = 0 for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]] const romanToInt = ( s ) => { const roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }; let ans = 0 for ( let i = 0 ; i < s . length ; ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans ; }; Analysis \u00b6 Time Complexity: \\(\\mathcal{O}(n)\\) Space Complexity: \\(\\mathcal{O}(1)\\)","title":"0013. Roman to Integer"},{"location":"en/leetcode/roman-to-integer/#0013-roman-to-integer","text":"","title":"0013. Roman to Integer"},{"location":"en/leetcode/roman-to-integer/#solutions","text":"","title":"Solutions"},{"location":"en/leetcode/roman-to-integer/#code","text":"C++ Java Python JavaScript class Solution { public : int romanToInt ( string s ) { vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; int ans = 0 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans + roman [ s . back ()]; } }; class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) { ans -= roman [ s . charAt ( i ) ] ; } else { ans += roman [ s . charAt ( i ) ] ; } } return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } class Solution : def romanToInt ( self , s : str ) -> int : roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } ans = 0 for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]] const romanToInt = ( s ) => { const roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }; let ans = 0 for ( let i = 0 ; i < s . length ; ++ i ) { if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) { ans -= roman [ s [ i ]]; } else { ans += roman [ s [ i ]]; } } return ans ; };","title":"Code"},{"location":"en/leetcode/roman-to-integer/#analysis","text":"Time Complexity: \\(\\mathcal{O}(n)\\) Space Complexity: \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/leetcode/two-sum/","text":"Two Sum \u00b6 Problem \u00b6 Solution \u00b6 C++ Java Python class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"Two Sum"},{"location":"en/leetcode/two-sum/#two-sum","text":"","title":"Two Sum"},{"location":"en/leetcode/two-sum/#problem","text":"","title":"Problem"},{"location":"en/leetcode/two-sum/#solution","text":"C++ Java Python class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"Solution"},{"location":"en/leetcode/valid-anagram/","text":"0242. Valid Anagram \u00b6 Solution: Hash Mapping \u00b6 Code \u00b6 C++ Java Python JavaScript class Solution { public : bool isAnagram ( string s , string t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t vector < int > count ( 128 ); for ( const char c : s ) { ++ count [ c ]; } for ( const char c : t ) { if ( -- count [ c ] < 0 ) return false ; } return true ; } }; class Solution { public boolean isAnagram ( String s , String t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) { ++ count [ c ] ; } for ( final char c : t . toCharArray ()) { if ( -- count [ c ] < 0 ) { return false ; } } return true ; } } from collections import Counter class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # anagram must have the same length if len ( s ) != len ( t ): return False # compare the number of each character in s and t return Counter ( s ) == Counter ( t ) const isAnagram = function ( s , t ) { // anagram must have the same length if ( s . length !== t . length ) { return false ; } // compare the number of each character in s and t const count = {}; for ( let i = 0 ; i < s . length ; ++ i ) { count [ s [ i ]] = ( count [ s [ i ]] || 0 ) + 1 ; } for ( let i = 0 ; i < t . length ; ++ i ) { if ( count [ t [ i ]]) { count [ t [ i ]] -= 1 ; } else { return false ; } } return true ; }; Analysis \u00b6 \u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"0242. Valid Anagram"},{"location":"en/leetcode/valid-anagram/#0242-valid-anagram","text":"","title":"0242. Valid Anagram"},{"location":"en/leetcode/valid-anagram/#solution-hash-mapping","text":"","title":"Solution: Hash Mapping"},{"location":"en/leetcode/valid-anagram/#code","text":"C++ Java Python JavaScript class Solution { public : bool isAnagram ( string s , string t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t vector < int > count ( 128 ); for ( const char c : s ) { ++ count [ c ]; } for ( const char c : t ) { if ( -- count [ c ] < 0 ) return false ; } return true ; } }; class Solution { public boolean isAnagram ( String s , String t ) { // anagram must have the same length if ( s . length () != t . length ()) { return false ; } // compare the number of each character in s and t int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) { ++ count [ c ] ; } for ( final char c : t . toCharArray ()) { if ( -- count [ c ] < 0 ) { return false ; } } return true ; } } from collections import Counter class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # anagram must have the same length if len ( s ) != len ( t ): return False # compare the number of each character in s and t return Counter ( s ) == Counter ( t ) const isAnagram = function ( s , t ) { // anagram must have the same length if ( s . length !== t . length ) { return false ; } // compare the number of each character in s and t const count = {}; for ( let i = 0 ; i < s . length ; ++ i ) { count [ s [ i ]] = ( count [ s [ i ]] || 0 ) + 1 ; } for ( let i = 0 ; i < t . length ; ++ i ) { if ( count [ t [ i ]]) { count [ t [ i ]] -= 1 ; } else { return false ; } } return true ; };","title":"Code"},{"location":"en/leetcode/valid-anagram/#analysis","text":"\u6642\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(n)\\) \u7a7a\u9593\u8907\u96dc\u5ea6\uff1a \\(\\mathcal{O}(1)\\)","title":"Analysis"},{"location":"en/patterns/0-or-1-knapsack/","text":"","title":"0/1 Knapsack"},{"location":"en/patterns/bitwise-xor/","text":"","title":"Bitwise XOR"},{"location":"en/patterns/breadth-first-search/","text":"","title":"Breadth First Search"},{"location":"en/patterns/cyclic-sort/","text":"","title":"Cyclic Sort"},{"location":"en/patterns/depth-first-search/","text":"","title":"Depth First Search"},{"location":"en/patterns/fast-slow-pointers/","text":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u00b6 \u6982\u5ff5\u8aaa\u660e \u00b6 \u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u53c8\u7a31\u70ba Floyd \u5224\u5708\u6f14\u7b97\u6cd5\uff08Floyd Cycle Detection Algorithm\uff09\u6216\u9f9c\u5154\u8cfd\u8dd1\u7b97\u6cd5\uff08Tortoise and Hare Algorithm\uff09\uff0c\u4f7f\u7528\u5169\u500b\u6307\u91dd\u4ee5\u4e0d\u540c\u7684\u901f\u5ea6\u5728\u9663\u5217\u3001\u5e8f\u5217\u6216\u93c8\u7d50\u4e32\u5217\u4e2d\u79fb\u52d5\uff0c\u5169\u500b\u6307\u91dd\u5728\u4e00\u500b\u5faa\u74b0\u93c8\u7d50\u4e32\u5217\u4e2d\u5fc5\u7136\u6703\u76f8\u9047\u3002 \u7279\u5fb5\u898f\u5f8b \u00b6 \u93c8\u7d50\u4e32\u5217\u3001\u74b0\u5f62\u93c8\u7d50\u4e32\u5217\uff08cyclic linked-list\uff09\u3001\u74b0\u5f62\u9663\u5217\uff08cyclic array\uff09 \u5224\u65b7\u7dda\u6027\u7d50\u69cb\u7279\u5fb5\uff1a\u7372\u53d6\u93c8\u7d50\u4e32\u5217\u9577\u5ea6\u3001\u5224\u65b7\u662f\u5426\u6709\u74b0\u3001\u5224\u65b7\u662f\u5426\u4ea4\u932f \u547d\u540d\u898f\u7bc4 \u00b6 slow , fast walker , runner \u984c\u76ee\u6574\u7406 \u00b6 0141 Linked List Cycle 0142 Linked List Cycle II 0143 Recorder List 0202 Happy Number 0234 Palindrome Linked List 0457 Circular Array Loop 0876 Middle of the Linked List \u53c3\u8003\u8cc7\u6599 \u00b6 Cycle detection | WikiPedia","title":"Fast-slow Pointers"},{"location":"en/patterns/fast-slow-pointers/#fast-slow-pointers","text":"","title":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09"},{"location":"en/patterns/fast-slow-pointers/#_1","text":"\u5feb\u6162\u6307\u91dd\uff08Fast-slow Pointers\uff09 \u53c8\u7a31\u70ba Floyd \u5224\u5708\u6f14\u7b97\u6cd5\uff08Floyd Cycle Detection Algorithm\uff09\u6216\u9f9c\u5154\u8cfd\u8dd1\u7b97\u6cd5\uff08Tortoise and Hare Algorithm\uff09\uff0c\u4f7f\u7528\u5169\u500b\u6307\u91dd\u4ee5\u4e0d\u540c\u7684\u901f\u5ea6\u5728\u9663\u5217\u3001\u5e8f\u5217\u6216\u93c8\u7d50\u4e32\u5217\u4e2d\u79fb\u52d5\uff0c\u5169\u500b\u6307\u91dd\u5728\u4e00\u500b\u5faa\u74b0\u93c8\u7d50\u4e32\u5217\u4e2d\u5fc5\u7136\u6703\u76f8\u9047\u3002","title":"\u6982\u5ff5\u8aaa\u660e"},{"location":"en/patterns/fast-slow-pointers/#_2","text":"\u93c8\u7d50\u4e32\u5217\u3001\u74b0\u5f62\u93c8\u7d50\u4e32\u5217\uff08cyclic linked-list\uff09\u3001\u74b0\u5f62\u9663\u5217\uff08cyclic array\uff09 \u5224\u65b7\u7dda\u6027\u7d50\u69cb\u7279\u5fb5\uff1a\u7372\u53d6\u93c8\u7d50\u4e32\u5217\u9577\u5ea6\u3001\u5224\u65b7\u662f\u5426\u6709\u74b0\u3001\u5224\u65b7\u662f\u5426\u4ea4\u932f","title":"\u7279\u5fb5\u898f\u5f8b"},{"location":"en/patterns/fast-slow-pointers/#_3","text":"slow , fast walker , runner","title":"\u547d\u540d\u898f\u7bc4"},{"location":"en/patterns/fast-slow-pointers/#_4","text":"0141 Linked List Cycle 0142 Linked List Cycle II 0143 Recorder List 0202 Happy Number 0234 Palindrome Linked List 0457 Circular Array Loop 0876 Middle of the Linked List","title":"\u984c\u76ee\u6574\u7406"},{"location":"en/patterns/fast-slow-pointers/#_5","text":"Cycle detection | WikiPedia","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"en/patterns/in-place-reversal-of-linked-list/","text":"","title":"In-place Reversal of Linked-List"},{"location":"en/patterns/k-way-merge/","text":"","title":"K-way Merge"},{"location":"en/patterns/merge-intervals/","text":"","title":"Merge Intervals"},{"location":"en/patterns/sliding-window/","text":"Sliding Window \u00b6 \u6982\u5ff5\u8aaa\u660e \u00b6 \u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09 \u4ea6\u5373\u5728\u9663\u5217\u4e2d\u5efa\u7acb\u4e00\u500b\u53ef\u79fb\u52d5\u7684\u7bc4\u570d\uff0c\u4e26\u5728\u7bc4\u570d\u5167\u585e\u5165\u6eff\u8db3\u689d\u4ef6\u7684\u5143\u7d20\uff0c\u6bcf\u6b21\u5faa\u74b0\u4fbf\u5c07\u53f3\u6307\u91dd\u5411\u524d\u79fb\u52d5\uff0c\u4e26\u6839\u64da\u60c5\u6cc1\u79fb\u52d5\u5de6\u6307\u91dd\u3002 \u7279\u5fb5\u898f\u5f8b \u00b6 \u9663\u5217/\u5b57\u4e32 \u6700\u9577\u6216\u6700\u77ed\u9023\u7e8c \u984c\u76ee\u6574\u7406 \u00b6 0003 Longest Substring Without Repeating Characters 0030 Substring with Concatenation of All Words 0076 Minimum Window Substring 0209 Minimum Size Subarray Sum 0239 Sliding Window Maximum 0424 Longest Repeating Character Replacement 0904 Fruit into Baskets","title":"Sliding Window"},{"location":"en/patterns/sliding-window/#sliding-window","text":"","title":"Sliding Window"},{"location":"en/patterns/sliding-window/#_1","text":"\u6ed1\u52d5\u7a97\u53e3\uff08sliding window\uff09 \u4ea6\u5373\u5728\u9663\u5217\u4e2d\u5efa\u7acb\u4e00\u500b\u53ef\u79fb\u52d5\u7684\u7bc4\u570d\uff0c\u4e26\u5728\u7bc4\u570d\u5167\u585e\u5165\u6eff\u8db3\u689d\u4ef6\u7684\u5143\u7d20\uff0c\u6bcf\u6b21\u5faa\u74b0\u4fbf\u5c07\u53f3\u6307\u91dd\u5411\u524d\u79fb\u52d5\uff0c\u4e26\u6839\u64da\u60c5\u6cc1\u79fb\u52d5\u5de6\u6307\u91dd\u3002","title":"\u6982\u5ff5\u8aaa\u660e"},{"location":"en/patterns/sliding-window/#_2","text":"\u9663\u5217/\u5b57\u4e32 \u6700\u9577\u6216\u6700\u77ed\u9023\u7e8c","title":"\u7279\u5fb5\u898f\u5f8b"},{"location":"en/patterns/sliding-window/#_3","text":"0003 Longest Substring Without Repeating Characters 0030 Substring with Concatenation of All Words 0076 Minimum Window Substring 0209 Minimum Size Subarray Sum 0239 Sliding Window Maximum 0424 Longest Repeating Character Replacement 0904 Fruit into Baskets","title":"\u984c\u76ee\u6574\u7406"},{"location":"en/patterns/subsets%20copy/","text":"","title":"Subsets copy"},{"location":"en/patterns/subsets/","text":"","title":"Subsets"},{"location":"en/patterns/top-k-elements/","text":"","title":"Top K Elements"},{"location":"en/patterns/topological-sort/","text":"","title":"Topological Sort"},{"location":"en/patterns/two-heaps/","text":"","title":"Two Heaps"},{"location":"en/patterns/two-pointers/","text":"","title":"Two Pointers"}]}